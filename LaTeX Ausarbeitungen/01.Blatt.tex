\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[german]{babel}
\selectlanguage{german}
\usepackage[T1]{fontenc}
\usepackage[parfill]{parskip}
\usepackage{color}
\usepackage{xcolor}
\usepackage{tabto}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm} %für das \qed Symbol. Außerdem gibt es eine proof environment
\usepackage{graphicx}
\usepackage{listings} % für code im Text
\usepackage{lstautogobble} % für Pseudo code wie im VL-Skript
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\SetKw{KwBy}{by}

\usepackage{tikz}
\usepackage[utf8]{inputenc}
%\usepackage{algpseudocode}
\newcommand{\LD}{\langle}
\newcommand{\RD}{\rangle}
 \usepackage[utf8]{inputenc}
\usepackage{geometry} %to change the site margin
\usepackage[justification=centering]{caption}
\geometry{left=3cm, right=2cm, top=2cm, bottom=2cm}
\theoremstyle{remark}
\newtheorem*{Behauptung}{Behauptung}
\renewcommand\thesection{Aufgabe \arabic{section}}
\renewcommand\thesubsection{\alph{subsection})}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\usepackage{array}   % for \newcolumntype macro
\newcolumntype{C}{>{$}c<{$}} % math-mode version of "l" column type
\newcommand\inductioneq{\stackrel{\mathclap{\normalfont\mbox{I.B.}}}{=}}


\title{Übung 1: Algorithmen und Datenstrukturen}
\author{Theodor Bajusz (7159556), Valerij Dobler (7068135), Robin Wannags (6948409)}

\begin{document}
\maketitle

\section{}

Betrachten Sie zwei Algorithmen $A$ und $B$ für das gleiche Problem. Algorithmus $A$ benötigt bei einer Eingabe der Größe $n$ genau $2n^2$ Basisoperationen, während Algorithmus $B$ genau $100n \ceil{ log_2 n}$ Basisoperationen benötigt. Betrachten Sie zwei Computer $C_1$ und $C_2$. Computer $C_1$ (Supercomputer) kann pro Sekunde $4,16 \cdot 10^{17}$ Basisoperationen durchführen. Computer $C_2$ (Handy) kann hingegen nur $3 \cdot 10^{11}$ Basisoperationen pro Sekunde durchführen.

\subsection{}

Wie lange braucht Algorithmus $A$ auf beiden Computern, um ein Problem der Größe $n_1 = 200, n2 = 2.7 \cdot 10^9$ und $n^3 = 10^{16}$ zu lösen? (Lösungen in Sekunden)

\begin{center}
    \begin{tabular}{C|C|C|C}
        n_i & 200 & 2,7 \cdot 10^9 & 10^{16} \\ \hline
        C_1 & \text{ca. } 1,92 \cdot 10^{-13} & \text{ca. } 35 & \text{ca. } 4,81 \cdot 10^{14} \\ \hline
        C_2 & \text{ca. } 2,67 \cdot 10^{-7} & 4,86 \cdot 10^7 & \text{ca. } 6,67 \cdot 10^{20} \\
    \end{tabular}
\end{center}


\subsection{}

Wie lange braucht Algorithmus $B$ auf beiden Computern, um ein Problem der Größe $n_1 = 200, n2 = 2.7 \cdot 10^9$ und $n^3 = 10^{16}$ zu lösen?

\begin{center}
    \begin{tabular}{C|C|C|C}
        n_i & 200 & 2,7 \cdot 10^9 & 10^{16} \\ \hline
        C_1 & \text{ca. } 3,85 \cdot 10^{-13} & \text{ca. } 2,08 \cdot 10^-5  & \text{ca. } 130 \\ \hline
        C_2 & \text{ca. } 5,33 \cdot 10^{-7} & 28,8 & 1,8 \cdot 10^{8} \\
    \end{tabular}
\end{center}

\subsection{}

Für welche Problemgrößen ist Algorithmus $A$ schneller und für welche ist Algorithmus $B$ schneller, wenn beide Algorithmen auf dem gleichen Computer laufen?

Algorithmus $A$ ist für die Eingabe $n = 200$ schneller. Bei den größeren Eingaben ist jeweils Algorithmus $B$ schneller.  

\section{}

Betrachten Sie das Problem {\it Zweit-Kleinstes-Element}
\begin{itemize}
    \item {\it Eingabe:} Ein Array $A[1, \ldots, n]$ von $n \geq 2$ Zahlen
    
    \item {\it Ausgabe:} Ein Index $i$, sodass es einen Index $j \neq i$ gibt mit $A[j] \leq A[i]$ und für alle Indizes $k \in \{ 1, 2, \ldots , n \} \setminus \{ j \}$ gilt $A[k] \geq A[i]$.

\end{itemize}

\subsection{}

Beschreiben Sie in Pseudocode einen Algorithmus der das Problem {\it Zweit-Kleinstes-Element} löst. (3 Punkte) \\

\begin{algorithm}[H]
\SetAlgoLined
\KwResult{Das zweit kleinste Element}
 \uIf{$A[1] \; \leq\; A[2]$}{
    $min \gets 1$\; % Index vom kleinsten Element
    $i \gets 2$\; % Index vom zweit-kleinsten Element
 }
 \uElse{
    $min \leftrightarrow i$\; % tauschen
 }
 $c \gets 3$\;
 \While{$c <= length(A)$}{
    \uIf{$A[c] \leq A[min]$}{ % Wert von aktuell betrachtetem Index (c) <= dem vom Index j (kleinster Wert)  ist
        $i \gets min$\;
        $min \gets c$\;
    }
     \uElseIf{$A[c] < A[i]$}{
        $i \gets c$\;
     }
     \uElse{
        NOP\;
     }
    $c++$\;
 }
 \Return $i$\;
\caption{ZweitKleinstesElement($A$)}
\end{algorithm}
\emph{NOP: No-Operation}


\subsection{} Beweisen Sie die Korrektheit Ihres Algorithmus mit Hilfe einer geeigneten Schleifeninvariante.

\begin{Behauptung}
%$\forall k \in [1, \ldots, c]: A[min] \leq A[i] \leq A[k]$, wobei $c$ der Index vom zuletzt-besuchten Eintrag in der For-Schleife ist.

Kandidat für $I(c,i,min)$ \\
$A[i] = min\{\; A[j] \;| \; j \in \{1,2, \ldots, c - 1\}\setminus min\}$
\end{Behauptung}

\begin{proof}
Durch Schleifeninvariante
\begin{enumerate}
    % Bsp: [7, 5, 6, 3]
    \item Initialisierung:
    % $I(c, i, min)$ \\
    O.b.d.A.: $A[1] \leq A[2] \implies i=2, min = 1$, sonst analog\\
    Somit gilt nach Zeile 6:
    \begin{itemize}
        \item $I(c, i, min) = I(3, 2, 1)$
        \item $I(3,2,1): \quad ''A[2] = min\{\; A[j] \;| \; j \in \{1,2, \ldots, 3 - 1\}\setminus 1\}=min\{\; A[2] \;\}''$
    \end{itemize}

    \item Erhaltung:
    In Iteration $c$ soll gelten:
    \begin{itemize}
        \item Annahme: $I(c, i, min)$ nach Zeile 7
        \item Ziel: $I(c+1, i, min)$ nach Zeile 15
        \item nach Zeile 8: \\
           $A[c] \leq A[min] = min\{A[1], \ldots, A[c-1]\}$ \\
           $\implies A[c] = min\{A[1],\ldots, A[c]\}$ \\
           $\implies A[i] = min\{\; A[j] \;| \; j \in \{1,2, \ldots, c\}\setminus c\}$\\
           $\iff I(c+1, i, min)$ schon nach Zeile 10, weil $i \gets min$ und $min \gets c$
       \item nach Zeile 11: \\
           $A[i] > A[c] > A[min] = min\{A[1], \ldots, A[c]\}$ \\
           $\implies A[c] = min\{\; A[j] \;| \; j \in \{1,2, \ldots, c\}\setminus min\}$\\
           $\implies I(c+1, i, min)$ nach Zeile 12, weil $i \gets c$
        \item nach Zeile 13 impliziert  \\
           $A[min] = min\{A[1], \ldots, A[c]\} \land A[i] = min\{\; A[j] \;| \; j \in \{1,2, \ldots, c\}\setminus min\}$ \\
           $\implies I(c+1, i, min)$
        \item also: $I(c + 1, i, min)$ nach Zeile 14
    \end{itemize}
    \item Terminierung:
    \begin{itemize}
        \item Ende letzter Schleifendurchlauf:\\
        $c = length(A)$
        \item nach Zeile 15 gilt also\\
        $I(length(A)+1, i, min)$ \\
        $\iff A[min] = min\{A[1], \ldots, A[c]\} \land A[i] = min\{\; A[j] \;| \; j \in \{1,2, \ldots, c\}\setminus min\}$
        \item gilt folglich auch vor Zeile 16
    \end{itemize}
\end{enumerate}
\end{proof}
\newpage
\subsection{} Analysieren Sie die worst-case Laufzeit des formulierten Algorithmus.

\begin{tabular}{r|r}
Zeile & Laufzeit \\ \hline
1  & $\mathcal{O}(1)$ \\
2  & $\mathcal{O}(1)$ \\
3  & $\mathcal{O}(1)$ \\
4  & $\mathcal{O}(1)$ \\
5  & $\mathcal{O}(1)$ \\
6  & $\mathcal{O}(1)$ \\
7  & $\sum_{i=2}^{n} \mathcal{O}(i)$ \\
8  & $\mathcal{O}(1)$ \\
9  & $\mathcal{O}(1)$ \\
10 & $\mathcal{O}(1)$ \\
11 & $\mathcal{O}(1)$ \\
12 & $\mathcal{O}(1)$ \\
13 & $\mathcal{O}(1)$ \\
14 & $\mathcal{O}(1)$ \\
15 & $\mathcal{O}(1)$ \\
17 & $\mathcal{O}(1)$ \\
\end{tabular}

\[
\stackrel{Theorem 2.7}{\implies} T(n) = \mathcal{O}(1) + \mathcal{O}(n-2) \cdot (8 \cdot \mathcal{O}(1))+ \mathcal{O}(1) = \mathcal{O}(n)
\]

Da wir immer über jedes Element des Arrays iterieren müssen, ist die asymptotische Laufzeit gleichzeitig die best- und worst-case Laufzeit unseres Algorithmus. Die Laufzeit ist nicht ausschlaggebend variabel.

\newpage
\section{}

sZeigen Sie, dass $(ln(x))^k = O(x^\epsilon).$ Hierbei sind $k$, $\epsilon$ Konstanten größer Null. \\ {\it Ein möglicher Hinweis: Zeigen Sie die Aussage zunächst für k = 1.}

\section{}

Ordnen Sie die folgenden Funktionen gemäß Ihres asymptotischen Wachstums und begründen Sie Ihre Antwort:

\[
f_1(n) = 3^n, \; f_2(n) = n \cdot ln(n), \; f_3(n) = 2^n, \; f_4(n) = e^{log_2(n)}, \; f_5(n) = n^n, f_6(n) = n^{3/2}, f_7(n) = n!
\]

Bsp.: \\
\[
f_4(n) < f_2(n) < f_6(n) < f_3(n) < f_1(n) < f_7(n) < f_5(n)
\]
Begründung: \\


\end{document}

%% Cheat Sheet
%\begin{Behauptung}
%	Sei $(\Omega,P)$ ein endlicher Wahrscheinlichkeitsraum. 
%	
%	Dann gilt $\forall A\subset B\subset\Omega : P(B\setminus A)=P(B)-P(A)$
%	
%	Insbesondere gilt $P(A)\leq P(B)$
%\end{Behauptung}
%
%\begin{proof}
%Es gilt $B = A\cup (B\setminus A)$ und $A\cap (B\setminus A) =\emptyset$. Nach \textbf{b)} gilt somit $P(B)=P(A)+P(B\setminus A)$. Umgestellt folgt $P(B\setminus A)=P(B)-P(A)$.
%
%$P(A)\leq P(B)$ folgt aus oben und $P(B\setminus A)\geq 0$.
%\end{proof}